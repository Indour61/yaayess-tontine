{% extends "base.html" %}
{% block title %}Assistant vocal YaayESS{% endblock %}

{% block content %}
<div class="container mt-4">
  <h2 class="mb-3">Assistant YaayESS â€“ Texte & Voix (FR / Wolof)</h2>

  <!-- Token CSRF injectÃ© cÃ´tÃ© serveur (fallback si cookie non lisible) -->
  <input type="hidden" id="csrfmiddlewaretoken" value="{{ csrf_token }}">

  <div class="mb-3">
    <label class="form-label" for="lang">Langue</label>
    <select id="lang" class="form-select" style="max-width:240px" aria-label="Choisir la langue">
      <option value="fr">FranÃ§ais</option>
      <option value="wo">Wolof</option>
    </select>
    <div class="form-text">La sÃ©lection est mÃ©morisÃ©e dans ce navigateur.</div>
  </div>

  <!-- Carte: Texte -->
  <div class="card mb-3">
    <div class="card-body">
      <div class="d-flex gap-2">
        <input id="textInput" class="form-control" placeholder="Ã‰cris ta questionâ€¦" aria-label="Saisir une question pour lâ€™assistant" />
        <button id="sendBtn" class="btn btn-primary" type="button">Envoyer</button>
      </div>
      <div class="mt-3">
        <div id="textResp" class="small" aria-live="polite"></div>
        <audio id="textAudio" class="mt-2 d-none" controls></audio>
      </div>
    </div>
  </div>

  <!-- Carte: Voix -->
  <div class="card">
    <div class="card-body">
      <p class="mb-2"><strong>Mode vocal</strong> â€“ clique pour parler, reclique pour arrÃªter.</p>
      <div class="d-flex gap-2">
        <button id="recBtn" class="btn btn-success" type="button">ğŸ™ï¸ DÃ©marrer</button>
        <button id="stopBtn" class="btn btn-secondary" type="button" disabled>â¹ï¸ ArrÃªter</button>
      </div>
      <div class="mt-3">
        <div id="voiceTrans" class="text-muted small" aria-live="polite"></div>
        <div id="voiceResp" class="small mt-2" aria-live="polite"></div>
        <audio id="voiceAudio" class="mt-2 d-none" controls></audio>
      </div>
    </div>
  </div>
</div>

<script>
  // ---------- CSRF ----------
  function getCsrfToken() {
    const el = document.getElementById("csrfmiddlewaretoken");
    if (el && el.value && el.value !== "NOTPROVIDED") return el.value;
    const m = document.cookie.match(/(^|;)\s*csrftoken=([^;]+)/);
    return m ? decodeURIComponent(m.pop()) : "";
  }
  let csrftoken = getCsrfToken();

  // ---------- Langue (persistance locale) ----------
  const langSel = document.getElementById("lang");
  try {
    const savedLang = localStorage.getItem("yaayess_ai_lang");
    if (savedLang) langSel.value = savedLang;
  } catch(_) {}
  langSel.addEventListener("change", () => {
    try { localStorage.setItem("yaayess_ai_lang", langSel.value); } catch(_) {}
  });

  // ---------- Utilitaires d'affichage ----------
  // âœ¨ strip * : enlÃ¨ve tous les astÃ©risques (Markdown ** / *)
  function stripStars(text) {
    return (text || "").replace(/\*/g, "").replace(/\s{2,}/g, " ").trim();
  }

  // ---------- Texte -> IA ----------
  const inputEl = document.getElementById("textInput");
  const sendBtn = document.getElementById("sendBtn");
  const textResp = document.getElementById("textResp");
  const textAudio = document.getElementById("textAudio");

  function setPending(btn, pending) {
    if (!btn) return;
    btn.disabled = !!pending;
    btn.classList.toggle("disabled", !!pending);
  }

  async function sendText() {
    const text = (inputEl.value || "").trim();
    if (!text || sendBtn.disabled) return;

    textResp.textContent = "â³ GÃ©nÃ©ration en coursâ€¦";
    textAudio.src = "";
    textAudio.classList.add("d-none");
    setPending(sendBtn, true);

    try {
      const r = await fetch("{% url 'assistant_ai:chat_text' %}", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": csrftoken
        },
        body: JSON.stringify({ message: text, lang: langSel.value }),
        credentials: "include",
        cache: "no-store"
      });

      let data = {};
      try { data = await r.json(); } catch (_) {}

      if (r.ok && data.ok) {
        // âœ¨ strip *
        textResp.textContent = stripStars(data.text || "");
        if (data.audio) {
          textAudio.src = data.audio;
          textAudio.classList.remove("d-none");
          textAudio.play().catch(()=>{});
        }
      } else if (r.status === 403) {
        textResp.textContent = "âš ï¸ 403 CSRF : recharge la page /ai/ui/ pour obtenir un nouveau cookie/token.";
      } else {
        const msg = (data && data.error) ? data.error : `HTTP ${r.status}`;
        textResp.textContent = "âš ï¸ Erreur: " + msg;
      }
    } catch (e) {
      textResp.textContent = "âš ï¸ RÃ©seau ou serveur indisponible.";
    } finally {
      setPending(sendBtn, false);
    }
  }

  sendBtn.addEventListener("click", sendText);
  inputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      sendText();
    }
  });

  // ---------- Enregistrement audio ----------
  const recBtn  = document.getElementById("recBtn");
  const stopBtn = document.getElementById("stopBtn");
  const voiceTrans = document.getElementById("voiceTrans");
  const voiceResp  = document.getElementById("voiceResp");
  const voiceAudio = document.getElementById("voiceAudio");

  let mediaRecorder = null;
  let chunks = [];
  let stopTimer = null;

  function safeStopStream(stream) {
    try { stream.getTracks().forEach(t => t.stop()); } catch (_) {}
  }

  async function pickMime() {
    const candidates = ["audio/webm", "audio/ogg", "audio/mp4", "audio/mpeg", ""];
    for (const type of candidates) {
      if (!type) return ""; // laisser le navigateur choisir
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(type)) {
        return type;
      }
    }
    return "";
  }

  recBtn.addEventListener("click", async () => {
    if (!navigator.mediaDevices || !window.MediaRecorder) {
      alert("Enregistrement non supportÃ© par ce navigateur.");
      return;
    }
    if (mediaRecorder && mediaRecorder.state !== "inactive") return;

    try {
      chunks = [];
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mimeType = await pickMime();
      mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);

      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        const type = mimeType || "audio/webm";
        const blob = new Blob(chunks, { type });
        chunks = [];
        await sendVoice(blob);
        safeStopStream(stream);
      };

      mediaRecorder.start();
      // SÃ©curitÃ©: stop auto aprÃ¨s 60s max
      stopTimer = setTimeout(() => {
        try {
          if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
        } catch(_) {}
      }, 60000);

      recBtn.disabled = true;
      stopBtn.disabled = false;
      voiceTrans.textContent = "ğŸ™ï¸ Enregistrement en coursâ€¦";
      voiceResp.textContent = "";
      voiceAudio.classList.add("d-none");
      voiceAudio.src = "";
    } catch (e) {
      alert("Impossible d'accÃ©der au micro : " + (e?.message || e));
    }
  });

  stopBtn.addEventListener("click", () => {
    try {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
      }
    } catch(_) {}
    if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
    recBtn.disabled = false;
    stopBtn.disabled = true;
  });

  async function sendVoice(blob) {
    const fd = new FormData();
    fd.append("lang", langSel.value);
    const filename = blob.type.includes("ogg") ? "input.ogg"
                  : blob.type.includes("mpeg") ? "input.mp3"
                  : blob.type.includes("mp4") ? "input.m4a"
                  : blob.type.includes("wav") ? "input.wav"
                  : "input.webm";
    fd.append("audio", blob, filename);

    voiceTrans.textContent = "â³ Transcription en coursâ€¦";
    voiceResp.textContent = "";

    try {
      const r = await fetch("{% url 'assistant_ai:chat_voice' %}", {
        method: "POST",
        headers: { "X-CSRFToken": csrftoken },
        body: fd,
        credentials: "include",
        cache: "no-store"
      });

      let data = {};
      try { data = await r.json(); } catch (_) {}

      if (r.ok && data.ok) {
        voiceTrans.textContent = data.user_text ? ("ğŸ—£ï¸ Tu as dit : " + data.user_text) : "(Transcription vide)";
        // âœ¨ strip *
        voiceResp.textContent  = stripStars(data.text || "");
        if (data.audio) {
          voiceAudio.src = data.audio;
          voiceAudio.classList.remove("d-none");
          voiceAudio.play().catch(()=>{});
        }
      } else if (r.status === 403) {
        voiceTrans.textContent = "";
        voiceResp.textContent  = "âš ï¸ 403 CSRF : recharge la page /ai/ui/ pour obtenir un nouveau cookie/token.";
      } else {
        const msg = (data && data.error) ? data.error : `HTTP ${r.status}`;
        voiceTrans.textContent = "";
        voiceResp.textContent  = "âš ï¸ Erreur: " + msg;
      }
    } catch (e) {
      voiceTrans.textContent = "";
      voiceResp.textContent  = "âš ï¸ RÃ©seau ou serveur indisponible.";
    } finally {
      recBtn.disabled = false;
      stopBtn.disabled = true;
      if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
      try {
        if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
      } catch(_) {}
    }
  }

  // Astuce: focus sur le champ texte au chargement
  setTimeout(() => { try { inputEl.focus(); } catch(_) {} }, 50);
</script>
{% endblock %}

