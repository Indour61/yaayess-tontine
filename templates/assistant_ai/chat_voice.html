{% extends "base.html" %}
{% block title %}Assistant vocal YaayESS{% endblock %}

{% block content %}
<div class="container mt-4">
  <h2 class="mb-3">Assistant YaayESS ‚Äì Texte & Voix (FR / Wolof)</h2>

  <!-- Token CSRF inject√© c√¥t√© serveur (fallback si cookie non lisible) -->
  <input type="hidden" id="csrfmiddlewaretoken" value="{{ csrf_token }}">

  <div class="mb-3">
    <label class="form-label">Langue</label>
    <select id="lang" class="form-select" style="max-width:240px">
      <option value="fr">Fran√ßais</option>
      <option value="wo">Wolof</option>
    </select>
  </div>

  <!-- Carte: Texte -->
  <div class="card mb-3">
    <div class="card-body">
      <div class="d-flex gap-2">
        <input id="textInput" class="form-control" placeholder="√âcris ta question..." />
        <button id="sendBtn" class="btn btn-primary" type="button">Envoyer</button>
      </div>
      <div id="textResp" class="mt-3"></div>
      <audio id="textAudio" class="mt-2 d-none" controls></audio>
    </div>
  </div>

  <!-- Carte: Voix -->
  <div class="card">
    <div class="card-body">
      <p><strong>Mode vocal</strong> ‚Äì clique pour parler, reclique pour arr√™ter.</p>
      <div class="d-flex gap-2">
        <button id="recBtn" class="btn btn-success" type="button">üéôÔ∏è D√©marrer</button>
        <button id="stopBtn" class="btn btn-secondary" type="button" disabled>‚èπÔ∏è Arr√™ter</button>
      </div>
      <div id="voiceTrans" class="mt-3 text-muted"></div>
      <div id="voiceResp" class="mt-2"></div>
      <audio id="voiceAudio" class="mt-2 d-none" controls></audio>
    </div>
  </div>
</div>

<script>
  // ---------- CSRF ----------
  function getCsrfToken() {
    // 1) depuis l'input cach√©e (OK m√™me si CSRF_COOKIE_HTTPONLY=True)
    const el = document.getElementById("csrfmiddlewaretoken");
    if (el && el.value && el.value !== "NOTPROVIDED") return el.value;
    // 2) fallback cookie (si lisible)
    const m = document.cookie.match(/(^|;)\s*csrftoken=([^;]+)/);
    return m ? m.pop() : "";
  }
  let csrftoken = getCsrfToken();

  const langSel = document.getElementById("lang");

  // ---------- Texte -> IA ----------
  const inputEl = document.getElementById("textInput");
  const sendBtn = document.getElementById("sendBtn");
  const textResp = document.getElementById("textResp");
  const textAudio = document.getElementById("textAudio");

  async function sendText() {
    const text = (inputEl.value || "").trim();
    if (!text || sendBtn.disabled) return;

    textResp.textContent = "‚è≥ G√©n√©ration en cours‚Ä¶";
    textAudio.src = "";
    textAudio.classList.add("d-none");
    sendBtn.disabled = true;

    try {
      const r = await fetch("{% url 'assistant_ai:chat_text' %}", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": csrftoken
        },
        body: JSON.stringify({ message: text, lang: langSel.value }),
        credentials: "include",
      });

      let data = {};
      try { data = await r.json(); } catch (_) {}

      if (r.ok && data.ok) {
        textResp.textContent = data.text || "";
        if (data.audio) {
          textAudio.src = data.audio;
          textAudio.classList.remove("d-none");
          textAudio.play().catch(()=>{});
        }
      } else if (r.status === 403) {
        textResp.textContent = "‚ö†Ô∏è 403 CSRF : recharge la page /ai/ui/ pour obtenir le cookie.";
      } else {
        const msg = (data && data.error) ? data.error : `HTTP ${r.status}`;
        textResp.textContent = "‚ö†Ô∏è Erreur: " + msg;
      }
    } catch (e) {
      textResp.textContent = "‚ö†Ô∏è R√©seau ou serveur indisponible.";
    } finally {
      sendBtn.disabled = false;
    }
  }

  sendBtn.addEventListener("click", sendText);
  inputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      sendText();
    }
  });

  // ---------- Enregistrement audio ----------
  const recBtn  = document.getElementById("recBtn");
  const stopBtn = document.getElementById("stopBtn");
  const voiceTrans = document.getElementById("voiceTrans");
  const voiceResp  = document.getElementById("voiceResp");
  const voiceAudio = document.getElementById("voiceAudio");

  let mediaRecorder = null;
  let chunks = [];
  let stopTimer = null;

  function safeStopStream(stream) {
    try { stream.getTracks().forEach(t => t.stop()); } catch (_) {}
  }

  async function pickMime() {
    const candidates = ["audio/webm", "audio/ogg", "audio/mp4", "audio/mpeg", ""];
    for (const type of candidates) {
      if (!type) return ""; // laisser le navigateur choisir
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(type)) {
        return type;
      }
    }
    return "";
  }

  recBtn.addEventListener("click", async () => {
    if (!navigator.mediaDevices || !window.MediaRecorder) {
      alert("Enregistrement non support√© par ce navigateur.");
      return;
    }
    if (mediaRecorder && mediaRecorder.state !== "inactive") return;

    try {
      chunks = [];
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mimeType = await pickMime();
      mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);

      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        const type = mimeType || "audio/webm";
        const blob = new Blob(chunks, { type });
        chunks = [];
        await sendVoice(blob);
        safeStopStream(stream);
      };

      mediaRecorder.start();
      // S√©curit√©: stop auto apr√®s 60s max
      stopTimer = setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
      }, 60000);

      recBtn.disabled = true;
      stopBtn.disabled = false;
      voiceTrans.textContent = "üéôÔ∏è Enregistrement en cours‚Ä¶";
      voiceResp.textContent = "";
      voiceAudio.classList.add("d-none");
      voiceAudio.src = "";
    } catch (e) {
      alert("Impossible d'acc√©der au micro : " + (e?.message || e));
    }
  });

  stopBtn.addEventListener("click", () => {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
    }
    if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
    recBtn.disabled = false;
    stopBtn.disabled = true;
  });

  async function sendVoice(blob) {
    const fd = new FormData();
    fd.append("lang", langSel.value);
    const filename = blob.type.includes("ogg") ? "input.ogg"
                  : blob.type.includes("mpeg") ? "input.mp3"
                  : blob.type.includes("mp4") ? "input.m4a"
                  : "input.webm";
    fd.append("audio", blob, filename);

    voiceTrans.textContent = "‚è≥ Transcription en cours‚Ä¶";
    voiceResp.textContent = "";

    try {
      const r = await fetch("{% url 'assistant_ai:chat_voice' %}", {
        method: "POST",
        headers: { "X-CSRFToken": csrftoken },
        body: fd,
        credentials: "include",
      });

      let data = {};
      try { data = await r.json(); } catch (_) {}

      if (r.ok && data.ok) {
        voiceTrans.textContent = data.user_text ? ("üó£Ô∏è Tu as dit : " + data.user_text) : "(Transcription vide)";
        voiceResp.textContent  = data.text || "";
        if (data.audio) {
          voiceAudio.src = data.audio;
          voiceAudio.classList.remove("d-none");
          voiceAudio.play().catch(()=>{});
        }
      } else if (r.status === 403) {
        voiceTrans.textContent = "";
        voiceResp.textContent  = "‚ö†Ô∏è 403 CSRF : recharge la page /ai/ui/ pour obtenir le cookie.";
      } else {
        const msg = (data && data.error) ? data.error : `HTTP ${r.status}`;
        voiceTrans.textContent = "";
        voiceResp.textContent  = "‚ö†Ô∏è Erreur: " + msg;
      }
    } catch (e) {
      voiceTrans.textContent = "";
      voiceResp.textContent  = "‚ö†Ô∏è R√©seau ou serveur indisponible.";
    } finally {
      recBtn.disabled = false;
      stopBtn.disabled = true;
      if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        try { mediaRecorder.stop(); } catch(_) {}
      }
    }
  }
</script>
{% endblock %}
